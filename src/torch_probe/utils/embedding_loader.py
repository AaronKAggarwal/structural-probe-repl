# src/torch_probe/utils/embedding_loader.py
from typing import Optional, List
import h5py
import numpy as np
import json

def load_embeddings_for_sentence(
    hdf5_file_object: h5py.File, sentence_key: str, requested_layer: int
) -> Optional[np.ndarray]:
    """
    Loads embeddings for a specific sentence and layer from an HDF5 file.
    This function is format-aware and handles both legacy ELMo-style HDF5s
    and modern HDF5s generated by `extract_embeddings.py`.

    Args:
        hdf5_file_object: An opened h5py.File object.
        sentence_key: The string key for the sentence (e.g., "0", "1", ...).
        requested_layer: The absolute layer index to extract (e.g., 7 for BERT's 7th layer).

    Returns:
        A NumPy array of shape (num_tokens, embedding_dimension), or None on error.
    """
    if sentence_key not in hdf5_file_object:
        # Using print for now, logging would be better
        print(f"Warning: Sentence key '{sentence_key}' not found in HDF5 file.")
        return None

    dataset = hdf5_file_object[sentence_key]
    feature_stack = dataset[()]

    if not isinstance(feature_stack, np.ndarray) or feature_stack.ndim != 3:
        print(f"Warning: Data for key '{sentence_key}' is not a 3D NumPy array.")
        return None

    # Check for modern HDF5 format by looking for the attribute
    if 'layers_extracted_indices' in hdf5_file_object.attrs:
        # MODERN HDF5 FORMAT
        layers_in_file_str = hdf5_file_object.attrs['layers_extracted_indices']
        layers_in_file: List[int] = json.loads(layers_in_file_str)
        
        try:
            # Find the index corresponding to the requested layer in our stored stack
            stack_index = layers_in_file.index(requested_layer)
        except ValueError:
            print(f"Warning: Requested layer {requested_layer} not found in this HDF5 file. "
                  f"Available layers: {layers_in_file}")
            return None
        
        if not (0 <= stack_index < feature_stack.shape[0]):
             print(f"Error: Mismatch between metadata and data shape for key '{sentence_key}'.")
             return None
             
        return feature_stack[stack_index, :, :]
    else:
        # LEGACY ELMo FORMAT
        if not (0 <= requested_layer < feature_stack.shape[0]):
            print(f"Warning: Invalid legacy layer_index {requested_layer} for key '{sentence_key}'. "
                  f"Stack has {feature_stack.shape[0]} layers.")
            return None
        return feature_stack[requested_layer, :, :]
